import express from 'express';
import multer from 'multer';
import { query } from '../config/database.js';
import { authenticate } from '../middleware/auth.js';
import streamifier from 'streamifier';

const router = express.Router();

// ‚úÖ Utilise memoryStorage pour Railway (pas de disque)
const storage = multer.memoryStorage();

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB max
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|webp|pdf|doc|docx|xls|xlsx|ppt|pptx/;
    const mimetype = allowedTypes.test(file.mimetype);

    if (mimetype) {
      return cb(null, true);
    } else {
      cb(new Error('Type de fichier non autoris√©. Types autoris√©s: images, PDF, documents Office'));
    }
  }
});

// Import cloudinary (nous allons v√©rifier s'il est configur√©)
let cloudinary;
try {
  cloudinary = (await import('../config/cloudinary.js')).default;
  console.log('‚òÅÔ∏è Cloudinary configur√©');
} catch (error) {
  console.log('‚ö†Ô∏è Cloudinary non disponible:', error.message);
}

/**
 * Upload buffer vers Cloudinary
 */
const uploadBufferToCloudinary = (buffer, originalname, folder = 'agadev') => {
  return new Promise((resolve, reject) => {
    if (!cloudinary) {
      return reject(new Error('Cloudinary non configur√©'));
    }

    const uploadStream = cloudinary.uploader.upload_stream(
      {
        folder: folder,
        resource_type: 'auto',
        quality: 'auto',
        fetch_format: 'auto'
      },
      (error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      }
    );

    streamifier.createReadStream(buffer).pipe(uploadStream);
  });
};

/**
 * POST /api/media/upload - Upload un fichier
 */
router.post('/upload', authenticate, upload.single('file'), async (req, res) => {
  try {
    console.log('üì§ D√©but de l\'upload...');
    
    if (!req.file) {
      return res.status(400).json({ 
        success: false,
        error: 'Aucun fichier s√©lectionn√©' 
      });
    }

    console.log('üìÑ Fichier re√ßu:', {
      nom: req.file.originalname,
      type: req.file.mimetype,
      taille: req.file.size,
      buffer: req.file.buffer ? 'oui' : 'non'
    });

    const { entity_type, entity_id } = req.body;
    let cloudinaryResult = null;
    let fileUrl = '#';
    let publicId = `local-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    // Essayer Cloudinary si configur√©
    if (cloudinary && 
        process.env.CLOUDINARY_CLOUD_NAME && 
        process.env.CLOUDINARY_API_KEY && 
        process.env.CLOUDINARY_API_SECRET) {
      
      try {
        console.log('‚òÅÔ∏è Tentative d\'upload vers Cloudinary...');
        cloudinaryResult = await uploadBufferToCloudinary(
          req.file.buffer,
          req.file.originalname,
          `agadev/${entity_type || 'general'}`
        );
        
        fileUrl = cloudinaryResult.secure_url;
        publicId = cloudinaryResult.public_id;
        
        console.log('‚úÖ Succ√®s Cloudinary:', {
          url: fileUrl,
          public_id: publicId
        });
        
      } catch (cloudinaryError) {
        console.error('‚ùå Erreur Cloudinary:', cloudinaryError.message);
        // On continue sans Cloudinary
      }
    } else {
      console.log('‚ö†Ô∏è Cloudinary non configur√©, stockage local uniquement');
    }

    // Enregistrer dans la base de donn√©es (structure actuelle de la table)
    const result = await query(
      `INSERT INTO media 
       (filename, original_name, url, mime_type, size, uploader_id)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [
        publicId,
        req.file.originalname,
        fileUrl,
        req.file.mimetype,
        req.file.size,
        req.user.id
      ]
    );

    const response = {
      success: true,
      message: cloudinaryResult ? 'Fichier upload√© avec succ√®s' : 'M√©tadonn√©es enregistr√©es (stockage local)',
      media: result.rows[0]
    };

    if (cloudinaryResult) {
      response.cloudinary_info = {
        public_id: cloudinaryResult.public_id,
        format: cloudinaryResult.format,
        url: cloudinaryResult.secure_url
      };
    } else {
      response.warning = 'Le fichier est stock√© localement seulement';
    }

    res.status(201).json(response);

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'upload:', error);
    res.status(500).json({
      success: false,
      error: '√âchec de l\'upload du fichier',
      details: error.message
    });
  }
});

/**
 * POST /api/media/upload-multiple - Upload multiple
 */
router.post('/upload-multiple', authenticate, upload.array('files', 5), async (req, res) => {
  try {
    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ 
        success: false,
        error: 'Aucun fichier s√©lectionn√©' 
      });
    }

    console.log(`üì§ Upload de ${req.files.length} fichier(s)...`);
    const uploadedFiles = [];
    const errors = [];

    for (const [index, file] of req.files.entries()) {
      try {
        console.log(`  ${index + 1}/${req.files.length}: ${file.originalname}`);
        
        let fileUrl = '#';
        let publicId = `local-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        // Essayer Cloudinary
        if (cloudinary) {
          try {
            const cloudinaryResult = await uploadBufferToCloudinary(
              file.buffer,
              file.originalname,
              'agadev/general'
            );
            fileUrl = cloudinaryResult.secure_url;
            publicId = cloudinaryResult.public_id;
          } catch (cloudinaryError) {
            console.error(`  ‚ö†Ô∏è Cloudinary √©chou√© pour ${file.originalname}:`, cloudinaryError.message);
          }
        }

        // Enregistrer dans la DB
        const result = await query(
          `INSERT INTO media 
           (filename, original_name, url, mime_type, size, uploader_id)
           VALUES ($1, $2, $3, $4, $5, $6)
           RETURNING *`,
          [
            publicId,
            file.originalname,
            fileUrl,
            file.mimetype,
            file.size,
            req.user.id
          ]
        );

        uploadedFiles.push(result.rows[0]);

      } catch (error) {
        console.error(`  ‚ùå Erreur pour ${file.originalname}:`, error.message);
        errors.push({
          file: file.originalname,
          error: error.message
        });
      }
    }

    res.status(201).json({
      success: true,
      message: `${uploadedFiles.length} fichier(s) trait√©(s)`,
      media: uploadedFiles,
      errors: errors.length > 0 ? errors : undefined,
      warning: !cloudinary ? 'Cloudinary non configur√© - stockage local seulement' : undefined
    });

  } catch (error) {
    console.error('‚ùå Erreur upload multiple:', error);
    res.status(500).json({
      success: false,
      error: '√âchec de l\'upload multiple',
      details: error.message
    });
  }
});

/**
 * GET /api/media - Lister les fichiers
 */
router.get('/', authenticate, async (req, res) => {
  try {
    const { limit = 20, offset = 0 } = req.query;

    const result = await query(
      `SELECT m.*, u.username as uploader_name
       FROM media m
       LEFT JOIN users u ON m.uploader_id = u.id
       ORDER BY m.created_at DESC
       LIMIT $1 OFFSET $2`,
      [parseInt(limit), parseInt(offset)]
    );

    const countResult = await query('SELECT COUNT(*) FROM media');
    const total = parseInt(countResult.rows[0].count);

    res.json({
      success: true,
      media: result.rows,
      pagination: {
        limit: parseInt(limit),
        offset: parseInt(offset),
        total,
        hasMore: (parseInt(offset) + result.rows.length) < total
      }
    });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration m√©dias:', error);
    res.status(500).json({ 
      success: false,
      error: '√âchec de la r√©cup√©ration des fichiers' 
    });
  }
});

/**
 * DELETE /api/media/:id - Supprimer un fichier
 */
router.delete('/:id', authenticate, async (req, res) => {
  try {
    const { id } = req.params;

    // R√©cup√©rer les infos du fichier
    const mediaResult = await query(
      'SELECT * FROM media WHERE id = $1',
      [id]
    );

    if (mediaResult.rows.length === 0) {
      return res.status(404).json({ 
        success: false,
        error: 'Fichier non trouv√©' 
      });
    }

    const media = mediaResult.rows[0];

    // Supprimer de Cloudinary si c'est un fichier Cloudinary
    if (media.filename && !media.filename.startsWith('local-') && cloudinary) {
      try {
        const resourceType = media.mime_type.startsWith('image/') ? 'image' : 'raw';
        await cloudinary.uploader.destroy(media.filename, {
          resource_type: resourceType
        });
        console.log(`‚úÖ Supprim√© de Cloudinary: ${media.filename}`);
      } catch (error) {
        console.error('‚ö†Ô∏è √âchec suppression Cloudinary:', error.message);
      }
    }

    // Supprimer de la base de donn√©es
    await query('DELETE FROM media WHERE id = $1', [id]);

    res.json({
      success: true,
      message: 'Fichier supprim√© avec succ√®s'
    });
  } catch (error) {
    console.error('‚ùå Erreur suppression:', error);
    res.status(500).json({ 
      success: false,
      error: '√âchec de la suppression' 
    });
  }
});

export default router;
